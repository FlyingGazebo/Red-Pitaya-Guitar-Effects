// -------------------------------------------------------------
//
// Module: Hhp
// Generated by MATLAB(R) 8.1 and the Filter Design HDL Coder 2.9.3.
// Generated on: 2015-09-07 11:00:45
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// AddPipelineRegisters: on
// Name: Hhp
// TargetLanguage: Verilog
// TestBenchName: Hhp_tb
// TestBenchStimulus: step ramp chirp 
// GenerateHDLTestBench: off

// Filter Specifications:
//
// Sampling Frequency : 125 kHz
// Response           : Highpass
// Specification      : Fst,Fp,Ast,Ap
// Stopband Edge      : 2 Hz
// Passband Edge      : 20 Hz
// Stopband Atten.    : 60 dB
// Passband Ripple    : 1 dB
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Multipliers           : 6
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form II, Second-Order Sections
// Number of Sections  : 2
// Stable              : No
// Linear Phase        : No
// Arithmetic          : fixed
// Numerator           : s14,12 -> [-2 2)
// Denominator         : s14,12 -> [-2 2)
// Scale Values        : s14,13 -> [-1 1)
// Input               : s14,13 -> [-1 1)
// Section Input       : s16,4 -> [-2048 2048)
// Section Output      : s16,5 -> [-1024 1024)
// Output              : s14,3 -> [-1024 1024)
// State               : s20,13 -> [-64 64)
// Numerator Prod      : s34,25 -> [-256 256)
// Denominator Prod    : s34,25 -> [-256 256)
// Numerator Accum     : s36,25 -> [-1024 1024)
// Denominator Accum   : s36,25 -> [-1024 1024)
// Round Mode          : nearest
// Overflow Mode       : saturate
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Hhp
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [13:0] filter_in; //sfix14_En13
  output  signed [13:0] filter_out; //sfix14_En3

////////////////////////////////////////////////////////////////
//Module Architecture: Hhp
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [13:0] scaleconst1 = 14'b01111111111110; //sfix14_En13
  parameter signed [13:0] coeff_b1_section1 = 14'b01000000000000; //sfix14_En12
  parameter signed [13:0] coeff_b2_section1 = 14'b10000000000000; //sfix14_En12
  parameter signed [13:0] coeff_b3_section1 = 14'b01000000000000; //sfix14_En12
  parameter signed [13:0] coeff_a2_section1 = 14'b10000000000010; //sfix14_En12
  parameter signed [13:0] coeff_a3_section1 = 14'b00111111111110; //sfix14_En12
  parameter signed [13:0] scaleconst2 = 14'b01111111111100; //sfix14_En13
  parameter signed [13:0] coeff_b1_section2 = 14'b01000000000000; //sfix14_En12
  parameter signed [13:0] coeff_b2_section2 = 14'b10000000000000; //sfix14_En12
  parameter signed [13:0] coeff_b3_section2 = 14'b01000000000000; //sfix14_En12
  parameter signed [13:0] coeff_a2_section2 = 14'b10000000000100; //sfix14_En12
  parameter signed [13:0] coeff_a3_section2 = 14'b00111111111100; //sfix14_En12
  // Signals
  reg  signed [13:0] input_register; // sfix14_En13
  wire signed [37:0] scale1; // sfix38_En26
  wire signed [27:0] mul_temp; // sfix28_En26
  wire signed [15:0] scaletypeconvert1; // sfix16_En4
  // Section 1 Signals 
  wire signed [35:0] a1sum1; // sfix36_En25
  wire signed [35:0] a2sum1; // sfix36_En25
  wire signed [35:0] b1sum1; // sfix36_En25
  wire signed [35:0] b2sum1; // sfix36_En25
  wire signed [19:0] typeconvert1; // sfix20_En13
  reg  signed [19:0] delay_section1 [0:1] ; // sfix20_En13
  wire signed [15:0] inputconv1; // sfix16_En4
  wire signed [33:0] a2mul1; // sfix34_En25
  wire signed [33:0] a3mul1; // sfix34_En25
  wire signed [33:0] b1mul1; // sfix34_En25
  wire signed [33:0] b2mul1; // sfix34_En25
  wire signed [33:0] b3mul1; // sfix34_En25
  wire signed [20:0] mulpwr2_temp; // sfix21_En13
  wire signed [35:0] sub_cast; // sfix36_En25
  wire signed [35:0] sub_cast_1; // sfix36_En25
  wire signed [36:0] sub_temp; // sfix37_En25
  wire signed [35:0] sub_cast_2; // sfix36_En25
  wire signed [35:0] sub_cast_3; // sfix36_En25
  wire signed [36:0] sub_temp_1; // sfix37_En25
  wire signed [35:0] b1multypeconvert1; // sfix36_En25
  wire signed [35:0] add_cast; // sfix36_En25
  wire signed [35:0] add_cast_1; // sfix36_En25
  wire signed [36:0] add_temp; // sfix37_En25
  wire signed [35:0] add_cast_2; // sfix36_En25
  wire signed [35:0] add_cast_3; // sfix36_En25
  wire signed [36:0] add_temp_1; // sfix37_En25
  wire signed [15:0] section_result1; // sfix16_En5
  reg  signed [15:0] sos_pipeline1; // sfix16_En5
  wire signed [37:0] scale2; // sfix38_En26
  wire signed [29:0] mul_temp_1; // sfix30_En18
  wire signed [15:0] scaletypeconvert2; // sfix16_En4
  // Section 2 Signals 
  wire signed [35:0] a1sum2; // sfix36_En25
  wire signed [35:0] a2sum2; // sfix36_En25
  wire signed [35:0] b1sum2; // sfix36_En25
  wire signed [35:0] b2sum2; // sfix36_En25
  wire signed [19:0] typeconvert2; // sfix20_En13
  reg  signed [19:0] delay_section2 [0:1] ; // sfix20_En13
  wire signed [15:0] inputconv2; // sfix16_En4
  wire signed [33:0] a2mul2; // sfix34_En25
  wire signed [33:0] a3mul2; // sfix34_En25
  wire signed [33:0] b1mul2; // sfix34_En25
  wire signed [33:0] b2mul2; // sfix34_En25
  wire signed [33:0] b3mul2; // sfix34_En25
  wire signed [20:0] mulpwr2_temp_1; // sfix21_En13
  wire signed [35:0] sub_cast_4; // sfix36_En25
  wire signed [35:0] sub_cast_5; // sfix36_En25
  wire signed [36:0] sub_temp_2; // sfix37_En25
  wire signed [35:0] sub_cast_6; // sfix36_En25
  wire signed [35:0] sub_cast_7; // sfix36_En25
  wire signed [36:0] sub_temp_3; // sfix37_En25
  wire signed [35:0] b1multypeconvert2; // sfix36_En25
  wire signed [35:0] add_cast_4; // sfix36_En25
  wire signed [35:0] add_cast_5; // sfix36_En25
  wire signed [36:0] add_temp_2; // sfix37_En25
  wire signed [35:0] add_cast_6; // sfix36_En25
  wire signed [35:0] add_cast_7; // sfix36_En25
  wire signed [36:0] add_temp_3; // sfix37_En25
  wire signed [13:0] output_typeconvert; // sfix14_En3
  reg  signed [13:0] output_register; // sfix14_En3

  // Block Statements
  always @ (posedge clk or posedge reset)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          input_register <= filter_in;
        end
      end
    end // input_reg_process

  assign mul_temp = input_register * scaleconst1;
  assign scale1 = $signed({{10{mul_temp[27]}}, mul_temp});

  assign scaletypeconvert1 = (scale1[37] == 1'b0 && scale1[36:21] == 16'b1111111111111111) ? 16'b0111111111111111 : ({scale1[37], scale1[37:21]} + 1)>>>1;

  //   ------------------ Section 1 ------------------

  assign typeconvert1 = ((a1sum1[35] == 1'b0 & a1sum1[34:31] != 4'b0000) || (a1sum1[35] == 1'b0 && a1sum1[31:12] == 20'b01111111111111111111) // special case0
) ? 20'b01111111111111111111 : 
      (a1sum1[35] == 1'b1 && a1sum1[34:31] != 4'b1111) ? 20'b10000000000000000000 : ({a1sum1[35], a1sum1[31:11]} + 1)>>>1;

  always @ (posedge clk or posedge reset)
    begin: delay_process_section1
      if (reset == 1'b1) begin
        delay_section1[0] <= 20'b00000000000000000000;
        delay_section1[1] <= 20'b00000000000000000000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section1[1] <= delay_section1[0];
          delay_section1[0] <= typeconvert1;
        end
      end
    end // delay_process_section1

  assign inputconv1 = scaletypeconvert1;

  assign a2mul1 = delay_section1[0] * coeff_a2_section1;

  assign a3mul1 = delay_section1[1] * coeff_a3_section1;

  assign b1mul1 = $signed({typeconvert1, 12'b000000000000});

  assign mulpwr2_temp = (delay_section1[0]==20'b10000000000000000000) ? $signed({1'b0, delay_section1[0]}) : -delay_section1[0];

  assign b2mul1 = $signed({mulpwr2_temp, 13'b0000000000000});

  assign b3mul1 = $signed({delay_section1[1], 12'b000000000000});

  assign sub_cast = (inputconv1[15] == 1'b0 & inputconv1[14] != 1'b0) ? 36'b011111111111111111111111111111111111 : 
      (inputconv1[15] == 1'b1 && inputconv1[14] != 1'b1) ? 36'b100000000000000000000000000000000000 : $signed({inputconv1, 21'b000000000000000000000});
  assign sub_cast_1 = $signed({{2{a2mul1[33]}}, a2mul1});
  assign sub_temp = sub_cast - sub_cast_1;
  assign a2sum1 = ((sub_temp[36] == 1'b0 & sub_temp[35] != 1'b0) || (sub_temp[36] == 1'b0 && sub_temp[35:0] == 36'b011111111111111111111111111111111111) // special case0
) ? 36'b011111111111111111111111111111111111 : 
      (sub_temp[36] == 1'b1 && sub_temp[35] != 1'b1) ? 36'b100000000000000000000000000000000000 : sub_temp[35:0];

  assign sub_cast_2 = a2sum1;
  assign sub_cast_3 = $signed({{2{a3mul1[33]}}, a3mul1});
  assign sub_temp_1 = sub_cast_2 - sub_cast_3;
  assign a1sum1 = ((sub_temp_1[36] == 1'b0 & sub_temp_1[35] != 1'b0) || (sub_temp_1[36] == 1'b0 && sub_temp_1[35:0] == 36'b011111111111111111111111111111111111) // special case0
) ? 36'b011111111111111111111111111111111111 : 
      (sub_temp_1[36] == 1'b1 && sub_temp_1[35] != 1'b1) ? 36'b100000000000000000000000000000000000 : sub_temp_1[35:0];

  assign b1multypeconvert1 = $signed({{2{b1mul1[33]}}, b1mul1});

  assign add_cast = b1multypeconvert1;
  assign add_cast_1 = $signed({{2{b2mul1[33]}}, b2mul1});
  assign add_temp = add_cast + add_cast_1;
  assign b2sum1 = ((add_temp[36] == 1'b0 & add_temp[35] != 1'b0) || (add_temp[36] == 1'b0 && add_temp[35:0] == 36'b011111111111111111111111111111111111) // special case0
) ? 36'b011111111111111111111111111111111111 : 
      (add_temp[36] == 1'b1 && add_temp[35] != 1'b1) ? 36'b100000000000000000000000000000000000 : add_temp[35:0];

  assign add_cast_2 = b2sum1;
  assign add_cast_3 = $signed({{2{b3mul1[33]}}, b3mul1});
  assign add_temp_1 = add_cast_2 + add_cast_3;
  assign b1sum1 = ((add_temp_1[36] == 1'b0 & add_temp_1[35] != 1'b0) || (add_temp_1[36] == 1'b0 && add_temp_1[35:0] == 36'b011111111111111111111111111111111111) // special case0
) ? 36'b011111111111111111111111111111111111 : 
      (add_temp_1[36] == 1'b1 && add_temp_1[35] != 1'b1) ? 36'b100000000000000000000000000000000000 : add_temp_1[35:0];

  assign section_result1 = (b1sum1[35] == 1'b0 && b1sum1[34:19] == 16'b1111111111111111) ? 16'b0111111111111111 : ({b1sum1[35], b1sum1[35:19]} + 1)>>>1;

  always @ (posedge clk or posedge reset)
    begin: sos_pipeline_process_section1
      if (reset == 1'b1) begin
        sos_pipeline1 <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sos_pipeline1 <= section_result1;
        end
      end
    end // sos_pipeline_process_section1

  assign mul_temp_1 = sos_pipeline1 * scaleconst2;
  assign scale2 = $signed({mul_temp_1, 8'b00000000});

  assign scaletypeconvert2 = (scale2[37] == 1'b0 && scale2[36:21] == 16'b1111111111111111) ? 16'b0111111111111111 : ({scale2[37], scale2[37:21]} + 1)>>>1;

  //   ------------------ Section 2 ------------------

  assign typeconvert2 = ((a1sum2[35] == 1'b0 & a1sum2[34:31] != 4'b0000) || (a1sum2[35] == 1'b0 && a1sum2[31:12] == 20'b01111111111111111111) // special case0
) ? 20'b01111111111111111111 : 
      (a1sum2[35] == 1'b1 && a1sum2[34:31] != 4'b1111) ? 20'b10000000000000000000 : ({a1sum2[35], a1sum2[31:11]} + 1)>>>1;

  always @ (posedge clk or posedge reset)
    begin: delay_process_section2
      if (reset == 1'b1) begin
        delay_section2[0] <= 20'b00000000000000000000;
        delay_section2[1] <= 20'b00000000000000000000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section2[1] <= delay_section2[0];
          delay_section2[0] <= typeconvert2;
        end
      end
    end // delay_process_section2

  assign inputconv2 = scaletypeconvert2;

  assign a2mul2 = delay_section2[0] * coeff_a2_section2;

  assign a3mul2 = delay_section2[1] * coeff_a3_section2;

  assign b1mul2 = $signed({typeconvert2, 12'b000000000000});

  assign mulpwr2_temp_1 = (delay_section2[0]==20'b10000000000000000000) ? $signed({1'b0, delay_section2[0]}) : -delay_section2[0];

  assign b2mul2 = $signed({mulpwr2_temp_1, 13'b0000000000000});

  assign b3mul2 = $signed({delay_section2[1], 12'b000000000000});

  assign sub_cast_4 = (inputconv2[15] == 1'b0 & inputconv2[14] != 1'b0) ? 36'b011111111111111111111111111111111111 : 
      (inputconv2[15] == 1'b1 && inputconv2[14] != 1'b1) ? 36'b100000000000000000000000000000000000 : $signed({inputconv2, 21'b000000000000000000000});
  assign sub_cast_5 = $signed({{2{a2mul2[33]}}, a2mul2});
  assign sub_temp_2 = sub_cast_4 - sub_cast_5;
  assign a2sum2 = ((sub_temp_2[36] == 1'b0 & sub_temp_2[35] != 1'b0) || (sub_temp_2[36] == 1'b0 && sub_temp_2[35:0] == 36'b011111111111111111111111111111111111) // special case0
) ? 36'b011111111111111111111111111111111111 : 
      (sub_temp_2[36] == 1'b1 && sub_temp_2[35] != 1'b1) ? 36'b100000000000000000000000000000000000 : sub_temp_2[35:0];

  assign sub_cast_6 = a2sum2;
  assign sub_cast_7 = $signed({{2{a3mul2[33]}}, a3mul2});
  assign sub_temp_3 = sub_cast_6 - sub_cast_7;
  assign a1sum2 = ((sub_temp_3[36] == 1'b0 & sub_temp_3[35] != 1'b0) || (sub_temp_3[36] == 1'b0 && sub_temp_3[35:0] == 36'b011111111111111111111111111111111111) // special case0
) ? 36'b011111111111111111111111111111111111 : 
      (sub_temp_3[36] == 1'b1 && sub_temp_3[35] != 1'b1) ? 36'b100000000000000000000000000000000000 : sub_temp_3[35:0];

  assign b1multypeconvert2 = $signed({{2{b1mul2[33]}}, b1mul2});

  assign add_cast_4 = b1multypeconvert2;
  assign add_cast_5 = $signed({{2{b2mul2[33]}}, b2mul2});
  assign add_temp_2 = add_cast_4 + add_cast_5;
  assign b2sum2 = ((add_temp_2[36] == 1'b0 & add_temp_2[35] != 1'b0) || (add_temp_2[36] == 1'b0 && add_temp_2[35:0] == 36'b011111111111111111111111111111111111) // special case0
) ? 36'b011111111111111111111111111111111111 : 
      (add_temp_2[36] == 1'b1 && add_temp_2[35] != 1'b1) ? 36'b100000000000000000000000000000000000 : add_temp_2[35:0];

  assign add_cast_6 = b2sum2;
  assign add_cast_7 = $signed({{2{b3mul2[33]}}, b3mul2});
  assign add_temp_3 = add_cast_6 + add_cast_7;
  assign b1sum2 = ((add_temp_3[36] == 1'b0 & add_temp_3[35] != 1'b0) || (add_temp_3[36] == 1'b0 && add_temp_3[35:0] == 36'b011111111111111111111111111111111111) // special case0
) ? 36'b011111111111111111111111111111111111 : 
      (add_temp_3[36] == 1'b1 && add_temp_3[35] != 1'b1) ? 36'b100000000000000000000000000000000000 : add_temp_3[35:0];

  assign output_typeconvert = (b1sum2[35] == 1'b0 && b1sum2[34:21] == 14'b11111111111111) ? 14'b01111111111111 : ({b1sum2[35], b1sum2[35:21]} + 1)>>>1;

  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = output_register;
endmodule  // Hhp
